---
layout: post
title: U8 최적화 optimization
---
****최적화(Optimization)의 개념****

최**적화, 最適化, optimization**

주어진 상황에서 원하는 가장 알맞은 결과를 얻을 수 있도록 처리하는 과정.
최적화는 허용된 자원의 한계 내에서 주어진 요구사항을 만족시키면서 최선의 결과를 얻는 과정이다. 수익과 관련되는 분야에서는 이익을 최대로 내는 과정을 말하기도 한다. 다양한 분야와 때에 따라 다르게 정의할 수 있고 물류(logistics), 설계(design) 문제 등에 응용된다.

****최적화의 필요성 및 효과****

****1. 이탈률 감소****

이탈 - 방문자가 웹 사이트의 첫 페이지에서 아무런 상호작용을 하지 않고 종료
웹 개발에서의 최적화는 화면을 최대한 빠른 속도로 표시하게 하는 것 → 로딩시간 줄이기
화면을 불러오는 시간이 길어지면 사용자가 페이지를 이탈할 확률이 높음.
구글의 조사 결과에 따르면 페이지 로드가 3초 이상 걸리면 53%의 사용자가 사이트를 이탈. 또한 페이지 로드 시간이 길어지면 사이트 방문자가 이탈률이 폭발적으로 증가. 페이지 로드 속도가 1초에서 3초로 늘어나면 이탈률은 32%, 5초로 늘어나면 90%, 6초로 늘어나면 106%, 10초로 늘어나면 123%까지 증가

****2. 전환율 증가****

전환율 - 웹 사이트를 방문한 사용자 중 회원가입, 상품 구매, 게시글 조회, 다운로드 등의 행위를 한 방문자의 비율
이탈해버린 사용자의 전환율은 0%. 전환율을 늘려 서비스 사용자를 늘리기 위해서는 이탈률을 감소시켜야 함

****3. 수익 증대****

로딩 속도가 1초 빨라졌을 때 아마존 판매량은 1%, 구글 검색량은 0.2%, 월마트의 전환율은 2% 증가
수치를 돈으로 환산하면 각각 68억 달러, 4억 5천만 달러, 2억 4천400만 달러의 매출 증가
로딩 속도의 차이는 이처럼 유의미한 수익 차이가 발생

****4. 사용자 경험(UX) 향상****

최적화는 효과적인 UX 개선 수단
이탈률 감소와 UX 향상 효과를 동시에 보기 위해서는 웹 사이트 성능 최적화

### **최적화 기법**

****리소스 로딩 최적화하기****

HTML 파일은 DOM 트리를, CSS 파일은 CSSOM 트리를 만들고 두 트리를 결합하여 렌더링
두 트리 중에서 하나라도 변경되면 리렌더링을 유발
트리의 크기가 크고 복잡할수록 더 많은 계산이 필요하기 때문에 리렌더링에 소모되는 시간 지체
HTML, CSS 코드를 최적화함으로써 렌더링 성능을 향상

****1. HTML 최적화 방법****

****(1) DOM 트리 가볍게 만들기****

```
// 수정 전
<div>
	<ol>
		<li> 첫 번째 </li>
		<li> 두 번째 </li>
		<li> 세 번째 </li>
	</ol>
</div>// 수정 후 : 불필요한 div 요소 제거
<ol>
	<li> 첫 번째 </li>
	<li> 두 번째 </li>
	<li> 세 번째 </li>
</ol>
```

DOM 트리가 깊을수록, 자식 요소가 많을수록 DOM 트리의 복잡도 증가, 
복잡도가 클 수록 DOM 트리가 변경되었을 때 계산량 증가
HTML 요소들의 관계를 잘 살펴보고, 불필요하게 깊이를 증가시키는 요소가 있다면 삭제

****(2) 인라인 스타일 사용하지 않기****

인라인 스타일은 웹 표준에 맞지 않으므로 지양
불필요한 코드 중복은 가독성을 떨어뜨릴 뿐 아니라 파일 크기를 증가
CSS 파일을 따로 작성하면 단 한 번의 리플로우만 발생하는 것과 달리, 
인라인 스타일은 리플로우를 계속해서 발생시켜 렌더링 완료 시점 지체

```
//수정 전
<div style="margin: 10px;"> 마진 10px </div><div style="margin: 10px;"> 이것도 마진 10px </div>//수정 후 : class와 CSS로 대체
<div class="margin10"> 마진 10px </div><div class="margin10"> 이것도 마진 10px </div>.margin10 {
	margin: 10px;
}
```

****2. CSS 최적화 방법****

****(1) 사용하지 않는 CSS 제거하기****

CSS 파일의 모든 코드의 분석이 끝난 후에 CSSOM 트리가 생성
불필요한 CSS 코드가 있다면 CSSOM 트리의 완성 지체
CSS 코드를 사용하던 요소를 삭제하면서 CSS 코드만 남지 않도록 주의

****(2) 간결한 셀렉터 사용하기****

셀렉터가 복잡할수록 스타일 계산과 레이아웃에 시간을 더 많이 소모

```
// 복잡한 CSS 셀렉터 예시
.cart_page .cart_item #firstItem { ... }

// 필요한 경우에는 어쩔 수 없지만, 가능한 한 간결하게 작성해줍니다.
.cart_item { ... }
```

## **캐시 관리**

캐시(Cache)는 다운로드 받은 데이터나 값을 미리 복사해 놓는 임시 장소를 뜻하며, 데이터에 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용

브라우저 캐시를 활용하면,

- 캐시가 유효한 시간 동안 네트워크 리소스를 아낄 수 있음
- 파일을 다시 받아올 필요가 없기 때문에 브라우저 로딩이 빨라짐
- 로딩이 빨라진 만큼 빠른 사용자 경험 제공 가능

****캐시 검증 헤더와 조건부 요청****

### **캐시 검증 헤더**

> 캐시에 저장된 데이터와 서버의 데이터가 동일한지 확인하기 위한 정보를 담은 응답 헤더
> 
> - `Last-Modified` : **데이터가 마지막으로 수정된 시점**을 의미하는 응답 헤더로, 조건부 요청 헤더인 `If-Modified-Since` 와 묶어서 사용
> - `Etag` : **데이터의 버전**을 의미하는 응답 헤더로, 조건부 요청 헤더인 `If-None-Match` 와 묶어서 사용

### **조건부 요청 헤더**

> 캐시의 데이터와 서버의 데이터가 동일하다면 재사용하게 해달라는 의미의 요청 헤더
> 
> - `If-Modified-Since` : 캐시된 리소스의 `Last-Modified` 값 이후에 서버 리소스가 수정되었는지 확인하고, 수정되지 않았다면 캐시된 리소스를 사용
> - `If-None-Match` : 캐시된 리소스의 `ETag` 값과 현재 서버 리소스의 `ETag` 값이 같은지 확인하고, 같으면 캐시된 리소스를 사용

****트리쉐이킹(Tree Shaking)****

나무를 흔들어 잔가지를 털어내듯 불필요한 코드를 제거하는 것을 의미
불필요한 코드들을 찾아내어 제거하면 웹 사이트 성능 최적화 가능

****1. JavaScript 파일의 크기의 대형화로 인한 감량 필요
2. JavaScript 파일의 실행 시간 최적화 필요****

****JavaScript 트리쉐이킹****

****1. 필요한 모듈만 import 하기
2. Babelrc 파일 설정하기 - ES5문법을 사용하지 않도록****

```
{
  “presets”: [
    [
      “@babel/preset-env”,
      {
	    "modules": false
      }
    ]
 ]
}
```

****3. sideEffects 설정하기 - 웹팩은 사이드 이펙트를 일으킬 수 있는 코드의 경우, 사용하지 않는 코드라도 트리쉐이킹 대상에서 제외필요
4. ES6 문법을 사용하는 모듈 사용하기****

### Lighthouse

Lighthouse는 구글에서 개발한 오픈소스로서 웹 페이지의 품질을 개선할 수 있는 자동화 툴
성능, 접근성, PWA, SEO 등을 검사하며 이를 이용해 사용자는 어떤 웹페이지든 품질 검사

## **Chrome 개발자 도구에서 실행하기**

1. 크롬에서 검사하고 싶은 페이지의 url을 입력합니다.
2. **개발자 도구**를 엽니다.
3. **lighthouse** 탭을 클릭합니다.

## **Node CLI에서 실행하기**

1. Lighthouse를 설치합니다. 이때`g` 옵션을 사용하여 Lighthouse를 전역 모듈로 설치하는 것이 좋습니다.
    
    ```
    npm install -g lighthouse
    ```
    
2. 다음의 명령어로 검사를 실행할 수 있습니다.
    
    ```
    lighthouse <url>
    ```
    
3. 다음의 명령어로 모든 옵션을 볼 수 있습니다.
    
    ```
    lighthouse --help
    ```
    
    [https://github.com/GoogleChrome/lighthouse/blob/main/docs/readme.md#using-programmatically](https://github.com/GoogleChrome/lighthouse/blob/main/docs/readme.md#using-programmatically)
    
    **Lighthouse 분석 결과 항목**
    
    ### **1. Performance**
    
    Performance 항목에서는 웹 성능을 측정. 화면에 콘텐츠가 표시되는데 시간이 얼마나 걸리는지, 표시된 후 사용자와 상호작용하기 까진 얼마나 걸리는지, 화면에 불안정한 요소는 없는지 등을 확인.
    
    ### **2. Accessibility**
    
    Accessibility 항목에서는 웹 페이지가 웹 접근성을 잘 갖추고 있는지 확인. 대체 텍스트를 잘 작성했는지, 배경색과 콘텐츠 색상의 대비가 충분한지, 적절한 WAI-ARIA 속성을 사용했는지 등을 확인.
    
    ### **3. Best Practices**
    
    Best Practices 항목에서는 웹 페이지가 웹 표준 모범 사례를 잘 따르고 있는지 확인. HTTPS 프로토콜을 사용하는지**,** 사용자가 확인할 확률은 높지 않지만 콘솔 창에 오류가 표시 되지는 않는지 등을 확인.
    
    ### **4. SEO**
    
    SEO 항목에서는 웹 페이지가 검색 엔진 최적화가 잘 되어있는지 확인. 애플리케이션의 robots.txt가 유효한지, `<meta>` 요소는 잘 작성되어 있는지, 텍스트 크기가 읽기에 무리가 없는지 등을 확인.
    
    ### **5. PWA (Progressive Web App)**
    
    PWA 항목에서는 해당 웹 사이트가 모바일 애플리케이션으로서도 잘 작동하는지 확인. 앱 아이콘을 제공하는지, 스플래시 화면이 있는지, 화면 크기에 맞게 콘텐츠를 적절하게 배치했는지 등을 점수가 아닌 체크리스트로 확인.
    
    ### ****Lighthouse의 Performance 측정 메트릭****
    
    1. First Contentful Paint, 줄여서 FCP는 **성능(Performance)** 지표를 추적하는 메트릭.
    
    FCP는 사용자가 페이지에 접속했을 때 브라우저가 DOM 컨텐츠의 첫 번째 부분을 렌더링하는 데 걸리는 시간을 측정. 즉 사용자가 감지하는 페이지의 로딩속도를 측정할 수 있습니다. 우수한 사용자 경험을 제공하려면 FCP가 **1.8초** 이하.
    
    1. Largest Contentful Paint, 줄여서 LCP는 뷰포트를 차지하는 가장 큰 콘텐츠(이미지 또는 텍스트 블록)의 렌더 시간을 측정. 이를 이용해 주요 콘텐츠가 유저에게 보이는 시간까지를 예측가능
    
    | LCP time(in seconds) | Color-coding |
    | --- | --- |
    | 0-2.5 | Green (fast) |
    | 2.5-4 | Orange (moderate) |
    | Over 4 | Red (slow) |
    1. Speed Index는 **성능(Performance)** 지표를 추적하는 메트릭 페이지를 로드하는 동안 얼마나 빨리 컨텐츠가 시각적으로 표시되는 지를 측정. Lighthouse는 먼저 브라우저의 페이지 로딩과정을 각 프레임마다 캡쳐합니다. 그리고 프레임 간 화면에 보이는 요소들을 계산합니다. 그 후 [Speedline Node.js module](https://github.com/paulirish/speedline)
    을 이용하여 Speed Index 점수를 그래프의 형태
    
    | Speed Index(in seconds) | Color-coding |
    | --- | --- |
    | 0–3.4 | Green (fast) |
    | 3.4–5.8 | Orange (moderate) |
    | Over 5.8 | Red (slow) |
    1. Time to interactive, 줄여서 TTI는 페이지가 로드되는 시점부터 사용자와의 상호작용이 가능한 시점까지의 시간을 측정
    
    TTI는 페이지가 완전히 상호 작용 가능하기까지의 시간을 측정합니다.
    
    - 페이지에 FCP로 측정된 컨텐츠가 표시.
    - 이벤트 핸들러가 가장 잘 보이는 페이지의 엘리먼트에 등록.
    - 페이지가 0.05초안에 사용자의 상호작용에 응답
    
    [https://httparchive.org/reports/loading-speed#ttci](https://httparchive.org/reports/loading-speed#ttci)
    
    | TTI metric(in seconds) | Color-coding |
    | --- | --- |
    | 0–3.8 | Green (fast) |
    | 3.9–7.3 | Orange (moderate) |
    | Over 7.3 | Red (slow) |
    1. ****Total Blocking Time****
    
    Total Blocking Time, 줄여서 TBT는 페이지가 유저와 상호작용하기까지의 막혀있는 시간을 측정합니다. Lighthouse에서는 FCP와 TTI 사이에 긴 시간이 걸리는 작업들을 모두 기록하여 TBT를 측정
    
    1. ****Cumulative Layout Shift
    Cumulative Layout Shift, 줄여서 CLS는 사용자에게 컨텐츠가 화면에서 얼마나 많이 움직이는지(불안정한 지)를 수치화한 지표. 이 지표를 통해 화면에서 이리저리 움직이는 요소(불안정한 요소)가 있는 지를 측정****
    [https://www.youtube.com/watch?v=zIJuY-JCjqw](https://www.youtube.com/watch?v=zIJuY-JCjqw)